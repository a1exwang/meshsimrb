# 图形学大作业报告
### 网格简化
1. 实现思路
    - 采用基于二次误差度量的简化技术(第8个ppt第63页)
    - 选取点对(v1,v2), 合并到某一点v, 直到面片数量符合要求为止.
    - 选取的原则, 求解70页的方程组, 如果有唯一解, 则取该解, 如果有无穷多解或者无解, 则取两点的中点.
2. 具体实现细节
    - 采用ruby实现, 将瓶颈用c-extension实现, 以实现开发效率和运行效率的大和谐...
    - 考虑到每次合并点后, 仅影响少数面片的矩阵kp, 所以, 应该缓存所有面片的kp和所有点对的最优点v和误差delta.
    - 由于每次选取最优点的规则是delta最小, 所以采用优先队列存所有点对(线段), 并且该优先队列应该支持O(log(N))时间的删除一个元素操作.
    - 由于经常需要求一个点所在的面和所在的线段, 所以, 在点的数据结构中缓存它所在的面的id和他所在线段的id
    - 所以最终的数据结构是:
        - Vertex哈希表, key是id, value是Vertex对象
        - Line哈希表, key是id, value是Line对象
        - Line Heap, 是按照line.delta排序的小顶堆
        - Face哈希表, key是id, value是Face对象
        - Vertex对象, 保存坐标, 所在直线的id, 所在面的id
        - Line对象, 保存点的id, delta值, 最优点v
        - Face对象, 保存点的id, kp矩阵
    - 合并两个点的过程
        1. 现将一个点移到最优点v
        1. 如果移动后存在同一个面上三点共线的情况(分新点在两点中间还是外部这两种情况), 则删掉该面, 同时删掉重合的直线其中之一, 把对被删掉直线的引用都改成没删掉那条的
        1. 重新计算影响的kp,delta和v
        1. 再将另一个点v2合并到v
        1. 需要删掉的面有faces(v2) \& faces(v), 需要更新kp的面有faces(v2) - faces(v)
        1. 需要删掉的线有v-v2, 需要更新delta的面有lines(vertexes(faces(v2) - faces(v)))
        1. 删掉点v2, 把对v2的引用改为对v的引用
        1. 注意可能产生退化成线段的面, 需要删掉

3. ruby层面的优化
    - 第一次profiler, 发现矩阵求通过kp求delta很费时间
    - 将kp用c-extension实现, 由于kp都是从一个四维向量来的, 所以可以在四维向量创建的时候就计算a*a, a*b等几项, 由于一个向量要对好几个cp有影响,
     然后用这个向量计算kp的时候就节省了重复计算.
    - 同样计算delta的时候也用到类似的技巧.(总体效率提高到原来的300%)
    - 利用gcc intrinsic来使用SIMD指令, 并行计算4个或者8个乘法, (总体效率提升30%左右)
    - 这都是一开始不解方程, 只合并到一个点的时候的优化策略, 大概能做到简化龙到5%时间十几秒
    - 解方程这里也可以利用预计算的方式减少重复计算. 估计能更快.
    
4. 运行方法
    - ruby -i infile_path -o outfile_path -r rate -s 
    - infile_path输入obj, outfile_path 输出obj, rate简化率(0, 1\], -s silent mode防止调试用的输出太费时间
1. 光线跟踪